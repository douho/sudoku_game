<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•¸ç¨éŠæˆ² Sudoku - Art Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden; /* é˜²æ­¢èƒŒæ™¯è¶…å‡º */
            background-color: #0f172a; /* é è¨­åº•è‰²ï¼ŒJS æœƒè¦†å¯« */
            transition: background-color 1s ease;
        }
        
        /* èƒŒæ™¯ Canvas */
        #art-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* æ”¾åœ¨æœ€åº•å±¤ */
        }

        /* éš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* ç°¡å–®çš„å½ˆè·³å‹•ç•« */
        @keyframes bounce-short {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-short {
            animation: bounce-short 0.5s ease-in-out infinite;
        }

        /* ç»ç’ƒæ“¬æ…‹æ¨¡ç³Š */
        .glass-panel {
            background: rgba(15, 23, 42, 0.6); /* é è¨­ï¼Œæœƒè¢«å‹•æ…‹æ¨£å¼è¦†è“‹ */
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 1s ease;
        }
        
        /* æ ¼å­é‚Šæ¡†é¡è‰²èª¿æ•´ */
        .sudoku-grid {
            border-color: rgba(255, 255, 255, 0.3);
        }
        .cell-border {
            border-color: rgba(255, 255, 255, 0.15);
        }
        /* å‹•æ…‹é‚Šæ¡† class æœƒåœ¨ React ä¸­ç”¢ç”Ÿ */
    </style>
</head>
<body class="text-slate-200">

    <!-- èƒŒæ™¯ç•«å¸ƒ -->
    <canvas id="art-canvas"></canvas>
    
    <div id="root" class="h-screen w-full overflow-y-auto"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- ç”Ÿæˆå¼è—è¡“èƒŒæ™¯é‚è¼¯ ---
        const GenerativeBackground = ({ onColorChange }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = document.getElementById('art-canvas');
                const ctx = canvas.getContext('2d');
                let animationFrameId;
                
                let width, height;
                let particles = [];
                let shapes = [];
                
                // è¨­å®šä¸»é¡Œè‰²
                // éš¨æ©Ÿè‰²ç›¸ 0-360
                const baseHue = Math.floor(Math.random() * 360);
                
                // èƒŒæ™¯ï¼šåŒè‰²ç›¸ï¼Œä½é£½å’Œ (15-25%)ï¼Œæ¥µä½äº®åº¦ (5-10%)
                const bgSat = 20; 
                const bgLight = 8;
                const bgColorString = `hsl(${baseHue}, ${bgSat}%, ${bgLight}%)`;
                
                // å…ƒç´ ï¼šåŒè‰²ç›¸ï¼Œä¸­é«˜é£½å’Œï¼Œé«˜äº®åº¦
                const elemSat = 70;
                const elemLight = 65;
                const colorPrefix = `hsla(${baseHue}, ${elemSat}%, ${elemLight}%, `;

                // å¥—ç”¨èƒŒæ™¯è‰²åˆ° body
                document.body.style.backgroundColor = bgColorString;
                
                // é€šçŸ¥ä¸Šå±¤çµ„ä»¶é¡è‰²å·²æ”¹è®Š (ç”¨æ–¼èª¿æ•´ç»ç’ƒé¢æ¿é¡è‰²)
                if (onColorChange) {
                    onColorChange(`hsla(${baseHue}, ${bgSat}%, ${bgLight+5}%, 0.6)`);
                }

                // æ±ºå®šè¦å•Ÿç”¨çš„å…ƒç´ é¡å‹ (æœ€å¤šé¸ 2 ç¨®)
                const allTypes = ['point', 'line', 'plane'];
                // æ´—ç‰Œ
                const shuffled = allTypes.sort(() => 0.5 - Math.random());
                // å–å‰ 1 æˆ– 2 å€‹
                const activeTypes = shuffled.slice(0, Math.floor(Math.random() * 2) + 1);
                
                const usePoints = activeTypes.includes('point');
                const useLines = activeTypes.includes('line');
                const usePlanes = activeTypes.includes('plane');

                // è¨­å®šç•«å¸ƒå°ºå¯¸
                const resize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resize);
                resize();

                // 1. ç²’å­ (é»/ç·šå…±ç”¨)
                class Particle {
                    constructor() {
                        this.init();
                    }
                    
                    init() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.vx = (Math.random() - 0.5) * 1.0; 
                        this.vy = (Math.random() - 0.5) * 1.0;
                        this.radius = Math.random() * 2 + 1;
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;

                        if (this.x < 0 || this.x > width) this.vx *= -1;
                        if (this.y < 0 || this.y > height) this.vy *= -1;
                    }

                    draw(ctx) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = colorPrefix + '0.8)';
                        ctx.fill();
                    }
                }

                // 2. å¹¾ä½•åœ–å½¢ (é¢)
                class FloatingShape {
                    constructor() {
                        this.init();
                    }

                    init() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.size = Math.random() * 150 + 50; 
                        this.angle = Math.random() * Math.PI * 2;
                        this.spin = (Math.random() - 0.5) * 0.005;
                        this.vx = (Math.random() - 0.5) * 0.2;
                        this.vy = (Math.random() - 0.5) * 0.2;
                        this.type = Math.random() > 0.5 ? 'square' : 'triangle';
                        this.opacity = 0;
                        this.fadingIn = true;
                        this.life = Math.random() * 0.002 + 0.001; 
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.angle += this.spin;

                        if (this.fadingIn) {
                            this.opacity += this.life;
                            if (this.opacity > 0.12) this.fadingIn = false; 
                        } else {
                            this.opacity -= this.life;
                            if (this.opacity < 0) this.init(); 
                        }

                        if (this.x < -200) this.x = width + 200;
                        if (this.x > width + 200) this.x = -200;
                        if (this.y < -200) this.y = height + 200;
                        if (this.y > height + 200) this.y = -200;
                    }

                    draw(ctx) {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        ctx.beginPath();
                        
                        // å¡«è‰²
                        ctx.fillStyle = colorPrefix + this.opacity + ')';
                        // é‚Šæ¡†
                        ctx.strokeStyle = colorPrefix + (this.opacity * 1.5) + ')';
                        ctx.lineWidth = 2;

                        if (this.type === 'square') {
                            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
                        } else {
                            const h = this.size * (Math.sqrt(3)/2);
                            ctx.moveTo(0, -h/2);
                            ctx.lineTo(this.size/2, h/2);
                            ctx.lineTo(-this.size/2, h/2);
                            ctx.closePath();
                        }

                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // åˆå§‹åŒ–ç‰©ä»¶
                const initItems = () => {
                    particles = [];
                    shapes = [];
                    // æ ¹æ“šé¸ä¸­çš„é¡å‹ç”Ÿæˆ
                    if (usePoints || useLines) {
                        const count = useLines ? 50 : 80; // å¦‚æœåªè¦é»ï¼Œå¯ä»¥å¤šä¸€é»
                        for (let i = 0; i < count; i++) particles.push(new Particle());
                    }
                    if (usePlanes) {
                        for (let i = 0; i < 8; i++) shapes.push(new FloatingShape());
                    }
                };
                initItems();

                // å‹•ç•«ä¸»è¿´åœˆ
                const animate = () => {
                    ctx.clearRect(0, 0, width, height);
                    
                    // 1. ç•«ã€Œé¢ã€
                    if (usePlanes) {
                        shapes.forEach(s => {
                            s.update();
                            s.draw(ctx);
                        });
                    }

                    // 2. ç•«ã€Œé»ã€èˆ‡ã€Œç·šã€
                    if (usePoints || useLines) {
                        ctx.globalCompositeOperation = 'lighter'; 
                        
                        particles.forEach(p => p.update());

                        // ç•«ç·š
                        if (useLines) {
                            ctx.lineWidth = 0.5;
                            for (let i = 0; i < particles.length; i++) {
                                const p1 = particles[i];
                                // å¦‚æœæœ‰é»ï¼Œå°±ç•«é»ï¼›å¦‚æœåªæœ‰ç·šï¼Œå°±ä¸ç•«åœ“é»æœ¬èº« (é¸ç”¨)
                                // é€™è£¡è¨­å®šï¼šå¦‚æœæœ‰é¸ points é¡å‹æ‰ç•«åœ“ï¼Œå¦å‰‡åªç•«ç·šçš„ç¯€é»
                                if (usePoints) p1.draw(ctx);

                                for (let j = i + 1; j < particles.length; j++) {
                                    const p2 = particles[j];
                                    const dx = p1.x - p2.x;
                                    const dy = p1.y - p2.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);

                                    if (dist < 130) {
                                        ctx.beginPath();
                                        const opacity = 1 - (dist / 130);
                                        ctx.strokeStyle = colorPrefix + (opacity * 0.4) + ')';
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.stroke();
                                    }
                                }
                            }
                        } else if (usePoints) {
                            // åªæœ‰é»ï¼Œæ²’æœ‰ç·š
                             particles.forEach(p => p.draw(ctx));
                        }
                        
                        ctx.globalCompositeOperation = 'source-over';
                    }

                    animationFrameId = requestAnimationFrame(animate);
                };
                animate();

                return () => {
                    window.removeEventListener('resize', resize);
                    cancelAnimationFrame(animationFrameId);
                };
            }, []);

            return null;
        };

        // --- å…§åµŒåœ–æ¨™å…ƒä»¶ ---

        const RefreshCw = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                <path d="M21 3v5h-5" />
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                <path d="M3 21v-5h5" />
            </svg>
        );

        const Trophy = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" />
                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" />
                <path d="M4 22h16" />
                <path d="M12 15.4V22" />
                <path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-2.26C5.19 13.47 4 11.38 4 9a7 7 0 0 1 7-7Z" />
            </svg>
        );

        const Pencil = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                <path d="m15 5 4 4" />
            </svg>
        );

        const Eraser = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21" />
                <path d="M22 21H7" />
                <path d="m5 11 9 9" />
            </svg>
        );

        const Clock = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10" />
                <polyline points="12 6 12 12 16 14" />
            </svg>
        );

        const Play = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 3 19 12 5 21 5 3" />
            </svg>
        );

        // --- æ•¸ç¨é‚è¼¯æ ¸å¿ƒ (æ”¯æ´ 6x6 èˆ‡ 9x9) ---

        // å–å¾—å®®æ ¼è³‡è¨Š
        // 9x9: 3x3 box
        // 6x6: 2x3 box (2 rows, 3 cols)
        const getBoxInfo = (size) => {
            if (size === 9) return { boxRows: 3, boxCols: 3 };
            if (size === 6) return { boxRows: 2, boxCols: 3 };
            return { boxRows: 3, boxCols: 3 };
        };

        const isValid = (board, row, col, num, size) => {
            const { boxRows, boxCols } = getBoxInfo(size);

            for (let i = 0; i < size; i++) {
                // Check Row & Col
                if (board[row][i] === num || board[i][col] === num) return false;
            }

            // Check Box
            const startRow = Math.floor(row / boxRows) * boxRows;
            const startCol = Math.floor(col / boxCols) * boxCols;

            for (let i = 0; i < boxRows; i++) {
                for (let j = 0; j < boxCols; j++) {
                    if (board[startRow + i][startCol + j] === num) return false;
                }
            }
            return true;
        };

        const solveSudoku = (board, size) => {
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (board[row][col] === 0) {
                        for (let num = 1; num <= size; num++) {
                            if (isValid(board, row, col, num, size)) {
                                board[row][col] = num;
                                if (solveSudoku(board, size)) return true;
                                board[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        };

        const generateFullBoard = (size) => {
            const board = Array.from({ length: size }, () => Array(size).fill(0));
            
            // éš¨æ©Ÿå¡«å…¥å°è§’ç·šçš„å®®æ ¼ (é€™äº›å®®æ ¼äº’ç›¸ç¨ç«‹)
            const { boxRows, boxCols } = getBoxInfo(size);
            
            // å°è§’ç·šå®®æ ¼çš„èµ·å§‹é»ï¼š (0,0), (boxRows, boxCols), ...
            // ä½† 6x6 ä¸æ˜¯æ­£æ–¹å½¢å®®æ ¼ (2x3)ï¼Œå°è§’ç·šé‚è¼¯æ¯”è¼ƒè¤‡é›œï¼Œé€™è£¡ç°¡åŒ–ï¼š
            // ç›´æ¥è§£é¡Œï¼Œåªéš¨æ©Ÿå¡«å…¥ç¬¬ä¸€è¡Œä»¥ç¢ºä¿éš¨æ©Ÿæ€§å³å¯
            
            // éš¨æ©Ÿå¡«ç¬¬ä¸€è¡Œ
            const firstRow = Array.from({length: size}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
            board[0] = firstRow;

            solveSudoku(board, size);
            return board;
        };

        const removeNumbers = (board, difficulty, size) => {
            const newBoard = board.map(row => [...row]);
            let holes = 0;
            
            // æ ¹æ“šå¤§å°èª¿æ•´æŒ–å­”æ•¸é‡
            // 9x9 (81æ ¼): Easy 30, Medium 45, Hard 55
            // 6x6 (36æ ¼): Easy 12, Medium 18, Hard 24
            
            if (size === 9) {
                if (difficulty === 'Easy') holes = 30;
                if (difficulty === 'Medium') holes = 45;
                if (difficulty === 'Hard') holes = 55;
            } else {
                if (difficulty === 'Easy') holes = 14;
                if (difficulty === 'Medium') holes = 19;
                if (difficulty === 'Hard') holes = 24;
            }

            while (holes > 0) {
                let row = Math.floor(Math.random() * size);
                let col = Math.floor(Math.random() * size);
                if (newBoard[row][col] !== 0) {
                    newBoard[row][col] = 0;
                    holes--;
                }
            }
            return newBoard;
        };

        // --- Main App Component ---

        function App() {
            const [gridSize, setGridSize] = useState(9); // 9 or 6
            const [initialBoard, setInitialBoard] = useState([]); 
            const [solvedBoard, setSolvedBoard] = useState([]);   
            const [gameBoard, setGameBoard] = useState([]);       
            const [notesBoard, setNotesBoard] = useState([]);
            const [selectedCell, setSelectedCell] = useState(null); 
            const [difficulty, setDifficulty] = useState('Easy');
            const [isWon, setIsWon] = useState(false);
            const [loading, setLoading] = useState(true);
            const [isNoteMode, setIsNoteMode] = useState(false);
            const [timer, setTimer] = useState(0); 
            const [isGameStarted, setIsGameStarted] = useState(false);
            const [panelBg, setPanelBg] = useState('rgba(15, 23, 42, 0.6)');

            const startNewGame = useCallback((diff = difficulty, size = gridSize) => {
                setLoading(true);
                localStorage.removeItem('sudoku-game-state');
                
                setIsGameStarted(false);

                setTimeout(() => {
                    const full = generateFullBoard(size);
                    const solved = full.map(row => [...row]);
                    const puzzle = removeNumbers(full, diff, size);
                    
                    setSolvedBoard(solved);
                    setInitialBoard(puzzle.map(row => [...row]));
                    setGameBoard(puzzle.map(row => [...row]));
                    
                    const initialNotes = Array.from({ length: size }, () => Array.from({ length: size }, () => []));
                    setNotesBoard(initialNotes);

                    setIsWon(false);
                    setSelectedCell(null);
                    setTimer(0);
                    setLoading(false);
                }, 50); 
            }, [difficulty, gridSize]);

            // åˆå§‹åŒ–èˆ‡è®€å–å­˜æª”
            useEffect(() => {
                const savedState = localStorage.getItem('sudoku-game-state');
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        // æª¢æŸ¥å­˜æª”çš„ gridSize æ˜¯å¦å­˜åœ¨ä¸”èˆ‡ç›®å‰è¨­å®šç›¸ç¬¦(ç°¡å–®èµ·è¦‹ï¼Œè®€å–å­˜æª”æœƒè¦†è“‹ç›®å‰çš„ gridSize)
                        if (parsed.gameBoard && parsed.initialBoard) {
                            const savedSize = parsed.gameBoard.length;
                            setGridSize(savedSize); // æ¢å¾©å¤§å°
                            setInitialBoard(parsed.initialBoard);
                            setSolvedBoard(parsed.solvedBoard);
                            setGameBoard(parsed.gameBoard);
                            setNotesBoard(parsed.notesBoard);
                            setDifficulty(parsed.difficulty);
                            setIsWon(parsed.isWon);
                            setTimer(parsed.timer || 0);
                            setLoading(false);
                            setIsGameStarted(false);
                            return;
                        }
                    } catch (e) {
                        console.error("è®€å–å­˜æª”å¤±æ•—", e);
                    }
                }
                startNewGame();
            }, []);

            // å­˜æª”
            useEffect(() => {
                if (loading || initialBoard.length === 0) return;
                const stateToSave = {
                    initialBoard, solvedBoard, gameBoard, notesBoard,
                    difficulty, isWon, timer
                };
                localStorage.setItem('sudoku-game-state', JSON.stringify(stateToSave));
            }, [gameBoard, notesBoard, difficulty, isWon, timer, initialBoard, solvedBoard]);

            // Timer
            useEffect(() => {
                let interval;
                if (!loading && !isWon && isGameStarted) {
                    interval = setInterval(() => {
                        setTimer(prev => prev + 1);
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [loading, isWon, isGameStarted]);

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };

            const handleNumberInput = (num) => {
                if (isWon || !selectedCell || !isGameStarted) return;
                // æª¢æŸ¥è¼¸å…¥æ•¸å­—ç¯„åœ
                if (num > gridSize) return;

                const [r, c] = selectedCell;
                if (initialBoard[r][c] !== 0) return;

                if (isNoteMode) {
                    if (gameBoard[r][c] !== 0) return;
                    const newNotes = [...notesBoard];
                    newNotes[r] = [...newNotes[r]];
                    const currentNotes = new Set(newNotes[r][c]);
                    if (currentNotes.has(num)) currentNotes.delete(num);
                    else currentNotes.add(num);
                    newNotes[r][c] = Array.from(currentNotes).sort((a,b)=>a-b);
                    setNotesBoard(newNotes);
                } else {
                    const newBoard = [...gameBoard];
                    if (newBoard[r][c] === num) newBoard[r][c] = 0;
                    else {
                        newBoard[r][c] = num;
                        const newNotes = [...notesBoard];
                        newNotes[r] = [...newNotes[r]];
                        newNotes[r][c] = [];
                        setNotesBoard(newNotes);
                    }
                    setGameBoard(newBoard);
                    
                    // Check Win
                    let isFull = true;
                    let isCorrect = true;
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            if (newBoard[i][j] === 0) isFull = false;
                            if (newBoard[i][j] !== solvedBoard[i][j]) isCorrect = false;
                        }
                    }
                    if (isFull && isCorrect) setIsWon(true);
                }
            };

            const handleErase = () => {
                if (isWon || !selectedCell || !isGameStarted) return;
                const [r, c] = selectedCell;
                if (initialBoard[r][c] !== 0) return;
                const newBoard = [...gameBoard];
                newBoard[r][c] = 0;
                setGameBoard(newBoard);
                const newNotes = [...notesBoard];
                newNotes[r][c] = [];
                setNotesBoard(newNotes);
            };

            // è™•ç†éµç›¤
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (isWon || !isGameStarted) return;
                    if (e.key >= '1' && e.key <= gridSize.toString()) {
                        handleNumberInput(parseInt(e.key));
                    }
                    if (e.key === 'Backspace' || e.key === 'Delete') handleErase();
                    if (e.key === 'n' || e.key === 'N') setIsNoteMode(prev => !prev);
                    
                    if (selectedCell) {
                        const [r, c] = selectedCell;
                        if (e.key === 'ArrowUp') setSelectedCell([Math.max(0, r - 1), c]);
                        if (e.key === 'ArrowDown') setSelectedCell([Math.min(gridSize - 1, r + 1), c]);
                        if (e.key === 'ArrowLeft') setSelectedCell([r, Math.max(0, c - 1)]);
                        if (e.key === 'ArrowRight') setSelectedCell([r, Math.min(gridSize - 1, c + 1)]);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedCell, gameBoard, notesBoard, isWon, isNoteMode, isGameStarted, gridSize]);

            const getCellClass = (r, c) => {
                const val = gameBoard[r][c];
                const isInitial = initialBoard[r][c] !== 0;
                const isSelected = selectedCell && selectedCell[0] === r && selectedCell[1] === c;
                
                let isRelated = false;
                let isSameNumber = false;
                
                const { boxRows, boxCols } = getBoxInfo(gridSize);

                if (selectedCell) {
                    const [sr, sc] = selectedCell;
                    const sVal = gameBoard[sr][sc];
                    
                    // Row, Col
                    let inBox = false;
                    const rStart = Math.floor(r/boxRows) * boxRows;
                    const cStart = Math.floor(c/boxCols) * boxCols;
                    const srStart = Math.floor(sr/boxRows) * boxRows;
                    const scStart = Math.floor(sc/boxCols) * boxCols;
                    if (rStart === srStart && cStart === scStart) inBox = true;

                    if (r === sr || c === sc || inBox) {
                        isRelated = true;
                    }
                    if (sVal !== 0 && val === sVal) {
                        isSameNumber = true;
                    }
                }

                let baseClass = "w-full h-full relative flex items-center justify-center cursor-pointer transition-colors duration-200 select-none cell-border border-[0.5px] ";
                
                // å‹•æ…‹é‚Šæ¡†é‚è¼¯
                // 9x9: æ¯ 3 è¡Œ (index 2, 5) åŠ ç²—å³é‚Šæ¡†
                // 6x6: æ¯ 3 è¡Œ (index 2) åŠ ç²—å³é‚Šæ¡† (boxCols = 3)
                if ((c + 1) % boxCols === 0 && c !== gridSize - 1) baseClass += "cell-border-bold-r ";
                
                // 9x9: æ¯ 3 åˆ— (index 2, 5) åŠ ç²—ä¸‹é‚Šæ¡†
                // 6x6: æ¯ 2 åˆ— (index 1, 3) åŠ ç²—ä¸‹é‚Šæ¡† (boxRows = 2)
                if ((r + 1) % boxRows === 0 && r !== gridSize - 1) baseClass += "cell-border-bold-b ";

                if (isSelected) {
                    baseClass += "bg-cyan-500/80 text-white shadow-[0_0_15px_rgba(6,182,212,0.6)] z-10 ";
                } else if (isSameNumber) {
                    baseClass += "bg-cyan-900/40 "; 
                } else if (isRelated) {
                    baseClass += "bg-slate-700/30 "; 
                } else {
                    baseClass += "hover:bg-white/5 ";
                }

                return baseClass;
            };

            const renderCellContent = (r, c) => {
                const val = gameBoard[r][c];
                const isInitial = initialBoard[r][c] !== 0;
                const isSelected = selectedCell && selectedCell[0] === r && selectedCell[1] === c;

                if (val !== 0) {
                    return (
                        <span className={`font-medium drop-shadow-md ${
                            gridSize === 9 ? 'text-lg sm:text-2xl' : 'text-xl sm:text-3xl'
                        } ${
                            !isSelected && !isInitial ? 'text-cyan-400' : '' 
                        } ${isInitial ? 'font-bold text-white' : ''} ${
                            isSelected ? 'text-white' : ''
                        }`}>
                            {val}
                        </span>
                    );
                }

                const notes = notesBoard[r] && notesBoard[r][c];
                if (notes && notes.length > 0) {
                    // 6x6 ç”¨ 2x3 çš„ grid é¡¯ç¤ºç­†è¨˜ï¼Œ9x9 ç”¨ 3x3
                    const gridCols = gridSize === 6 ? 'grid-cols-3' : 'grid-cols-3';
                    return (
                        <div className={`grid ${gridCols} gap-0 w-full h-full p-[2px]`}>
                            {Array.from({length: gridSize}, (_, i) => i+1).map(n => (
                                <div key={n} className="flex items-center justify-center text-[8px] sm:text-[10px] leading-none text-pink-300/80 font-medium">
                                    {notes.includes(n) ? n : ''}
                                </div>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            return (
                <div className="relative min-h-screen flex flex-col items-center py-8 font-sans text-slate-200">
                    <GenerativeBackground onColorChange={setPanelBg} />
                    
                    <div className="mb-6 flex flex-col items-center w-full max-w-[450px] px-4 z-10">
                        <div className="flex justify-between items-center w-full mb-4">
                            <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 drop-shadow-sm">
                                æ•¸ç¨ Sudoku
                            </h1>
                            <div className="flex items-center gap-3">
                                <div className="flex items-center text-cyan-100 px-3 py-1.5 rounded-lg border border-slate-700 shadow-sm" style={{background: panelBg}}>
                                    <Clock className="w-4 h-4 mr-2 text-cyan-400" />
                                    <span className="font-mono font-medium">{formatTime(timer)}</span>
                                </div>
                                <button 
                                    onClick={() => {
                                        if(confirm('ç¢ºå®šè¦æ”¾æ£„ç•¶å‰é€²åº¦ä¸¦é–‹å§‹æ–°éŠæˆ²å—ï¼Ÿ')) {
                                            startNewGame(difficulty, gridSize);
                                        }
                                    }}
                                    className="p-2 rounded-full transition text-cyan-100 border border-slate-700 hover:bg-white/10"
                                    style={{background: panelBg}}
                                    title="æ–°éŠæˆ²"
                                >
                                    <RefreshCw className="w-5 h-5" />
                                </button>
                            </div>
                        </div>
                        
                        <div className="flex flex-col w-full gap-2 p-3 rounded-lg shadow-lg glass-panel" style={{background: panelBg}}>
                            {/* ç¬¬ä¸€åˆ—ï¼šè¨­å®š */}
                            <div className="flex justify-between items-center">
                                <div className="flex items-center gap-3">
                                     <select 
                                        value={gridSize} 
                                        onChange={(e) => {
                                            const newSize = parseInt(e.target.value);
                                            if(confirm(`åˆ‡æ›ç‚º ${newSize}x${newSize} å°‡é–‹å§‹æ–°éŠæˆ²ï¼Œç¢ºå®šå—ï¼Ÿ`)) {
                                                setGridSize(newSize);
                                                startNewGame(difficulty, newSize);
                                            }
                                        }}
                                        className="bg-slate-900/50 border border-slate-600 rounded px-2 py-1 text-sm outline-none focus:border-cyan-500 text-slate-200"
                                    >
                                        <option value="9">9 x 9 (æ¨™æº–)</option>
                                        <option value="6">6 x 6 (è¿·ä½ )</option>
                                    </select>
                                    <select 
                                        value={difficulty} 
                                        onChange={(e) => {
                                            if(confirm('è®Šæ›´é›£åº¦å°‡é–‹å§‹æ–°éŠæˆ²ï¼Œç¢ºå®šå—ï¼Ÿ')) {
                                                setDifficulty(e.target.value);
                                                startNewGame(e.target.value, gridSize);
                                            }
                                        }}
                                        className="bg-slate-900/50 border border-slate-600 rounded px-2 py-1 text-sm outline-none focus:border-cyan-500 text-slate-200"
                                    >
                                        <option value="Easy">ç°¡å–®</option>
                                        <option value="Medium">ä¸­ç­‰</option>
                                        <option value="Hard">å›°é›£</option>
                                    </select>
                                </div>
                                <div className="text-sm text-cyan-300 font-medium">
                                    {isNoteMode ? 'âœï¸ è‰ç¨¿æ¨¡å¼' : 'âœï¸ ç­”é¡Œæ¨¡å¼'}
                                </div>
                            </div>
                        </div>
                    </div>

                    {isWon && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md">
                            <div className="p-8 rounded-2xl shadow-2xl flex flex-col items-center animate-bounce-short border border-cyan-500/30 glass-panel" style={{background: panelBg}}>
                                <Trophy className="w-16 h-16 text-yellow-400 mb-4 drop-shadow-[0_0_10px_rgba(250,204,21,0.5)]" />
                                <h2 className="text-3xl font-bold text-white mb-2">æ­å–œç²å‹ï¼</h2>
                                <p className="text-slate-300 mb-2">{gridSize}x{gridSize} - {difficulty}</p>
                                <p className="text-cyan-300 mb-6 font-mono text-lg">è€—æ™‚: {formatTime(timer)}</p>
                                <button 
                                    onClick={() => startNewGame(difficulty, gridSize)}
                                    className="px-6 py-2 bg-gradient-to-r from-cyan-600 to-blue-600 text-white rounded-full hover:from-cyan-500 hover:to-blue-500 transition shadow-lg flex items-center"
                                >
                                    <RefreshCw className="w-4 h-4 mr-2" />
                                    å†ä¾†ä¸€å±€
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="relative p-1 rounded-lg shadow-2xl select-none z-10 overflow-hidden glass-panel" style={{background: panelBg}}>
                        
                        {!isGameStarted && !loading && !isWon && (
                            <div className="absolute inset-0 z-40 flex flex-col items-center justify-center bg-slate-900/80 backdrop-blur-sm">
                                <div className="text-center">
                                    <div className="text-6xl mb-6">ğŸ§©</div>
                                    <button 
                                        onClick={() => setIsGameStarted(true)}
                                        className="group relative px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-full font-bold text-xl shadow-[0_0_20px_rgba(8,145,178,0.5)] transition-all hover:scale-105 active:scale-95 overflow-hidden"
                                    >
                                        <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div>
                                        <span className="relative flex items-center">
                                            <Play className="w-6 h-6 mr-2 fill-current" />
                                            {timer > 0 ? 'ç¹¼çºŒéŠæˆ²' : 'é–‹å§‹éŠæˆ²'}
                                        </span>
                                    </button>
                                </div>
                            </div>
                        )}

                        {loading ? (
                            <div className="w-[300px] h-[300px] sm:w-[450px] sm:h-[450px] flex items-center justify-center text-cyan-400">
                                ç”Ÿæˆé¡Œç›®ä¸­...
                            </div>
                        ) : (
                            <div 
                                className={`grid w-[300px] h-[300px] sm:w-[450px] sm:h-[450px] sudoku-grid border-2 transition-all duration-500 ${!isGameStarted ? 'blur-sm opacity-50' : ''} ${gridSize === 9 ? 'grid-cols-9' : 'grid-cols-6'}`}
                                style={{ touchAction: 'manipulation' }}
                            >
                                {gameBoard.map((row, r) => (
                                    row.map((num, c) => (
                                        <div
                                            key={`${r}-${c}`}
                                            onClick={() => setSelectedCell([r, c])}
                                            className={getCellClass(r, c)}
                                        >
                                            {renderCellContent(r, c)}
                                        </div>
                                    ))
                                ))}
                            </div>
                        )}
                    </div>

                    <div className="mt-6 w-full max-w-[450px] px-4 z-10">
                        
                        <div className="flex justify-between gap-2 mb-4">
                            <button 
                                onClick={() => setIsNoteMode(false)}
                                disabled={!isGameStarted}
                                className={`flex-1 py-3 rounded-lg flex items-center justify-center font-medium transition-all ${
                                    !isNoteMode 
                                    ? 'bg-cyan-600 text-white shadow-[0_0_10px_rgba(8,145,178,0.4)]' 
                                    : 'glass-panel text-slate-300 hover:bg-white/5'
                                } ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <span className="mr-2 text-lg">âœï¸</span> ç­”é¡Œ
                            </button>
                            <button 
                                onClick={() => setIsNoteMode(true)}
                                disabled={!isGameStarted}
                                className={`flex-1 py-3 rounded-lg flex items-center justify-center font-medium transition-all ${
                                    isNoteMode 
                                    ? 'bg-pink-600 text-white shadow-[0_0_10px_rgba(219,39,119,0.4)]' 
                                    : 'glass-panel text-slate-300 hover:bg-white/5'
                                } ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <Pencil className="w-5 h-5 mr-2" /> è‰ç¨¿
                            </button>
                            <button 
                                onClick={handleErase}
                                disabled={!isGameStarted}
                                className={`w-16 rounded-lg flex items-center justify-center glass-panel text-slate-300 hover:bg-white/10 transition-colors ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                                title="æ¸…é™¤æ ¼å­"
                                style={{background: panelBg}}
                            >
                                <Eraser className="w-6 h-6" />
                            </button>
                        </div>

                        {/* æ•¸å­—éµç›¤ï¼šæ ¹æ“š Grid Size å‹•æ…‹èª¿æ•´ */}
                        <div className={`grid gap-1 sm:gap-2 ${gridSize === 9 ? 'grid-cols-9' : 'grid-cols-6'}`}>
                            {Array.from({length: gridSize}, (_, i) => i+1).map(num => (
                                <button
                                    key={num}
                                    onClick={() => handleNumberInput(num)}
                                    disabled={!isGameStarted}
                                    className={`aspect-square flex items-center justify-center rounded shadow text-xl sm:text-2xl font-bold transition border border-white/10 ${
                                        isGameStarted 
                                        ? 'text-cyan-400 hover:bg-cyan-500/20 hover:text-cyan-200 active:bg-cyan-500/40' 
                                        : 'text-slate-600 cursor-not-allowed'
                                    }`}
                                    style={{background: panelBg}}
                                >
                                    {num}
                                </button>
                            ))}
                        </div>
                        
                        <div className="mt-4 text-center text-slate-500 text-xs">
                            éµç›¤æ·å¾‘: æ•¸å­—éµè¼¸å…¥ â€¢ æ–¹å‘éµç§»å‹• â€¢ Backspace æ¸…é™¤ â€¢ N åˆ‡æ›æ¨¡å¼
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
