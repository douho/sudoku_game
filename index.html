<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•¸ç¨éŠæˆ² Sudoku - Art Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden; /* é˜²æ­¢èƒŒæ™¯è¶…å‡º */
            background-color: #0f172a; /* é è¨­åº•è‰²ï¼ŒJS æœƒè¦†å¯« */
            transition: background-color 1s ease;
        }
        
        /* èƒŒæ™¯ Canvas */
        #art-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* æ”¾åœ¨æœ€åº•å±¤ */
        }

        /* éš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* ç°¡å–®çš„å½ˆè·³å‹•ç•« */
        @keyframes bounce-short {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-short {
            animation: bounce-short 0.5s ease-in-out infinite;
        }

        /* ç»ç’ƒæ“¬æ…‹æ¨¡ç³Š */
        .glass-panel {
            background: rgba(15, 23, 42, 0.6); /* é è¨­ï¼Œæœƒè¢«å‹•æ…‹æ¨£å¼è¦†è“‹ */
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 1s ease;
        }
        
        /* æ ¼å­é‚Šæ¡†é¡è‰²èª¿æ•´ */
        .sudoku-grid {
            border-color: rgba(255, 255, 255, 0.3);
        }
        .cell-border {
            border-color: rgba(255, 255, 255, 0.15);
        }
        /* å‹•æ…‹é‚Šæ¡† class æœƒåœ¨ React ä¸­ç”¢ç”Ÿ */
    </style>
</head>
<body class="text-slate-200">

    <!-- èƒŒæ™¯ç•«å¸ƒ -->
    <canvas id="art-canvas"></canvas>
    
    <div id="root" class="h-screen w-full overflow-y-auto"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- ç”Ÿæˆå¼è—è¡“èƒŒæ™¯é‚è¼¯ ---
        const GenerativeBackground = ({ onColorChange }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = document.getElementById('art-canvas');
                const ctx = canvas.getContext('2d');
                let animationFrameId;
                
                let width, height;
                let particles = [];
                let shapes = [];
                
                // è¨­å®šä¸»é¡Œè‰²
                const baseHue = Math.floor(Math.random() * 360);
                
                const bgSat = 20; 
                const bgLight = 8;
                const bgColorString = `hsl(${baseHue}, ${bgSat}%, ${bgLight}%)`;
                
                const elemSat = 70;
                const elemLight = 65;
                const colorPrefix = `hsla(${baseHue}, ${elemSat}%, ${elemLight}%, `;

                document.body.style.backgroundColor = bgColorString;
                
                if (onColorChange) {
                    onColorChange(`hsla(${baseHue}, ${bgSat}%, ${bgLight+5}%, 0.6)`);
                }

                const allTypes = ['point', 'line', 'plane'];
                const shuffled = allTypes.sort(() => 0.5 - Math.random());
                const activeTypes = shuffled.slice(0, Math.floor(Math.random() * 2) + 1);
                
                const usePoints = activeTypes.includes('point');
                const useLines = activeTypes.includes('line');
                const usePlanes = activeTypes.includes('plane');

                const resize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resize);
                resize();

                class Particle {
                    constructor() {
                        this.init();
                    }
                    
                    init() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.vx = (Math.random() - 0.5) * 1.0; 
                        this.vy = (Math.random() - 0.5) * 1.0;
                        this.radius = Math.random() * 2 + 1;
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;

                        if (this.x < 0 || this.x > width) this.vx *= -1;
                        if (this.y < 0 || this.y > height) this.vy *= -1;
                    }

                    draw(ctx) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = colorPrefix + '0.8)';
                        ctx.fill();
                    }
                }

                class FloatingShape {
                    constructor() {
                        this.init();
                    }

                    init() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.size = Math.random() * 150 + 50; 
                        this.angle = Math.random() * Math.PI * 2;
                        this.spin = (Math.random() - 0.5) * 0.005;
                        this.vx = (Math.random() - 0.5) * 0.2;
                        this.vy = (Math.random() - 0.5) * 0.2;
                        this.type = Math.random() > 0.5 ? 'square' : 'triangle';
                        this.opacity = 0;
                        this.fadingIn = true;
                        this.life = Math.random() * 0.002 + 0.001; 
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.angle += this.spin;

                        if (this.fadingIn) {
                            this.opacity += this.life;
                            if (this.opacity > 0.12) this.fadingIn = false; 
                        } else {
                            this.opacity -= this.life;
                            if (this.opacity < 0) this.init(); 
                        }

                        if (this.x < -200) this.x = width + 200;
                        if (this.x > width + 200) this.x = -200;
                        if (this.y < -200) this.y = height + 200;
                        if (this.y > height + 200) this.y = -200;
                    }

                    draw(ctx) {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        ctx.beginPath();
                        
                        ctx.fillStyle = colorPrefix + this.opacity + ')';
                        ctx.strokeStyle = colorPrefix + (this.opacity * 1.5) + ')';
                        ctx.lineWidth = 2;

                        if (this.type === 'square') {
                            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
                        } else {
                            const h = this.size * (Math.sqrt(3)/2);
                            ctx.moveTo(0, -h/2);
                            ctx.lineTo(this.size/2, h/2);
                            ctx.lineTo(-this.size/2, h/2);
                            ctx.closePath();
                        }

                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                const initItems = () => {
                    particles = [];
                    shapes = [];
                    if (usePoints || useLines) {
                        const count = useLines ? 50 : 80;
                        for (let i = 0; i < count; i++) particles.push(new Particle());
                    }
                    if (usePlanes) {
                        for (let i = 0; i < 8; i++) shapes.push(new FloatingShape());
                    }
                };
                initItems();

                const animate = () => {
                    ctx.clearRect(0, 0, width, height);
                    
                    if (usePlanes) {
                        shapes.forEach(s => {
                            s.update();
                            s.draw(ctx);
                        });
                    }

                    if (usePoints || useLines) {
                        ctx.globalCompositeOperation = 'lighter'; 
                        
                        particles.forEach(p => p.update());

                        if (useLines) {
                            ctx.lineWidth = 0.5;
                            for (let i = 0; i < particles.length; i++) {
                                const p1 = particles[i];
                                if (usePoints) p1.draw(ctx);

                                for (let j = i + 1; j < particles.length; j++) {
                                    const p2 = particles[j];
                                    const dx = p1.x - p2.x;
                                    const dy = p1.y - p2.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);

                                    if (dist < 130) {
                                        ctx.beginPath();
                                        const opacity = 1 - (dist / 130);
                                        ctx.strokeStyle = colorPrefix + (opacity * 0.4) + ')';
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.stroke();
                                    }
                                }
                            }
                        } else if (usePoints) {
                             particles.forEach(p => p.draw(ctx));
                        }
                        
                        ctx.globalCompositeOperation = 'source-over';
                    }

                    animationFrameId = requestAnimationFrame(animate);
                };
                animate();

                return () => {
                    window.removeEventListener('resize', resize);
                    cancelAnimationFrame(animationFrameId);
                };
            }, []);

            return null;
        };

        // --- å…§åµŒåœ–æ¨™å…ƒä»¶ ---

        const RefreshCw = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                <path d="M21 3v5h-5" />
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                <path d="M3 21v-5h5" />
            </svg>
        );

        const Trophy = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" />
                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" />
                <path d="M4 22h16" />
                <path d="M12 15.4V22" />
                <path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-2.26C5.19 13.47 4 11.38 4 9a7 7 0 0 1 7-7Z" />
            </svg>
        );

        const Pencil = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                <path d="m15 5 4 4" />
            </svg>
        );

        const Eraser = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21" />
                <path d="M22 21H7" />
                <path d="m5 11 9 9" />
            </svg>
        );

        const Clock = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10" />
                <polyline points="12 6 12 12 16 14" />
            </svg>
        );

        const Play = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 3 19 12 5 21 5 3" />
            </svg>
        );

        const Undo = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M3 7v6h6" />
                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
            </svg>
        );

        const Bot = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 8V4H8" />
                <rect width="16" height="12" x="4" y="8" rx="2" />
                <path d="M2 14h2" />
                <path d="M20 14h2" />
                <path d="M15 13v2" />
                <path d="M9 13v2" />
            </svg>
        );

        // --- æ•¸ç¨é‚è¼¯æ ¸å¿ƒ (æ”¯æ´ 6x6 èˆ‡ 9x9) ---

        const getBoxInfo = (size) => {
            if (size === 9) return { boxRows: 3, boxCols: 3 };
            if (size === 6) return { boxRows: 2, boxCols: 3 };
            return { boxRows: 3, boxCols: 3 };
        };

        const isValid = (board, row, col, num, size) => {
            const { boxRows, boxCols } = getBoxInfo(size);

            for (let i = 0; i < size; i++) {
                if (board[row][i] === num || board[i][col] === num) return false;
            }

            const startRow = Math.floor(row / boxRows) * boxRows;
            const startCol = Math.floor(col / boxCols) * boxCols;

            for (let i = 0; i < boxRows; i++) {
                for (let j = 0; j < boxCols; j++) {
                    if (board[startRow + i][startCol + j] === num) return false;
                }
            }
            return true;
        };

        const solveSudoku = (board, size) => {
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (board[row][col] === 0) {
                        for (let num = 1; num <= size; num++) {
                            if (isValid(board, row, col, num, size)) {
                                board[row][col] = num;
                                if (solveSudoku(board, size)) return true;
                                board[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        };

        const generateFullBoard = (size) => {
            const board = Array.from({ length: size }, () => Array(size).fill(0));
            const firstRow = Array.from({length: size}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
            board[0] = firstRow;
            solveSudoku(board, size);
            return board;
        };

        const removeNumbers = (board, difficulty, size) => {
            const newBoard = board.map(row => [...row]);
            let holes = 0;
            
            if (size === 9) {
                if (difficulty === 'Easy') holes = 30;
                if (difficulty === 'Medium') holes = 45;
                if (difficulty === 'Hard') holes = 55;
            } else {
                if (difficulty === 'Easy') holes = 14;
                if (difficulty === 'Medium') holes = 19;
                if (difficulty === 'Hard') holes = 24;
            }

            while (holes > 0) {
                let row = Math.floor(Math.random() * size);
                let col = Math.floor(Math.random() * size);
                if (newBoard[row][col] !== 0) {
                    newBoard[row][col] = 0;
                    holes--;
                }
            }
            return newBoard;
        };

        // --- Main App Component ---

        function App() {
            const [gridSize, setGridSize] = useState(9); // 9 or 6
            const [initialBoard, setInitialBoard] = useState([]); 
            const [solvedBoard, setSolvedBoard] = useState([]);   
            const [gameBoard, setGameBoard] = useState([]);       
            const [notesBoard, setNotesBoard] = useState([]);
            const [history, setHistory] = useState([]); // Undo æ­·å²ç´€éŒ„
            const [selectedCell, setSelectedCell] = useState(null); 
            const [difficulty, setDifficulty] = useState('Easy');
            const [isWon, setIsWon] = useState(false);
            const [loading, setLoading] = useState(true);
            const [isNoteMode, setIsNoteMode] = useState(false);
            const [timer, setTimer] = useState(0); 
            const [isGameStarted, setIsGameStarted] = useState(false);
            const [panelBg, setPanelBg] = useState('rgba(15, 23, 42, 0.6)');
            const [hintMessage, setHintMessage] = useState(null); // AI æç¤ºè¨Šæ¯

            const startNewGame = useCallback((diff = difficulty, size = gridSize) => {
                setLoading(true);
                localStorage.removeItem('sudoku-game-state');
                
                setIsGameStarted(false);
                setHistory([]); // æ¸…ç©ºæ­·å²
                setHintMessage(null);

                setTimeout(() => {
                    const full = generateFullBoard(size);
                    const solved = full.map(row => [...row]);
                    const puzzle = removeNumbers(full, diff, size);
                    
                    setSolvedBoard(solved);
                    setInitialBoard(puzzle.map(row => [...row]));
                    setGameBoard(puzzle.map(row => [...row]));
                    
                    const initialNotes = Array.from({ length: size }, () => Array.from({ length: size }, () => []));
                    setNotesBoard(initialNotes);

                    setIsWon(false);
                    setSelectedCell(null);
                    setTimer(0);
                    setLoading(false);
                }, 50); 
            }, [difficulty, gridSize]);

            useEffect(() => {
                const savedState = localStorage.getItem('sudoku-game-state');
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        if (parsed.gameBoard && parsed.initialBoard) {
                            const savedSize = parsed.gameBoard.length;
                            setGridSize(savedSize); 
                            setInitialBoard(parsed.initialBoard);
                            setSolvedBoard(parsed.solvedBoard);
                            setGameBoard(parsed.gameBoard);
                            setNotesBoard(parsed.notesBoard);
                            setDifficulty(parsed.difficulty);
                            setIsWon(parsed.isWon);
                            setTimer(parsed.timer || 0);
                            setHistory(parsed.history || []);
                            setLoading(false);
                            setIsGameStarted(false);
                            return;
                        }
                    } catch (e) {
                        console.error("è®€å–å­˜æª”å¤±æ•—", e);
                    }
                }
                startNewGame();
            }, []);

            useEffect(() => {
                if (loading || initialBoard.length === 0) return;
                const stateToSave = {
                    initialBoard, solvedBoard, gameBoard, notesBoard,
                    difficulty, isWon, timer, history
                };
                localStorage.setItem('sudoku-game-state', JSON.stringify(stateToSave));
            }, [gameBoard, notesBoard, difficulty, isWon, timer, initialBoard, solvedBoard, history]);

            useEffect(() => {
                let interval;
                if (!loading && !isWon && isGameStarted) {
                    interval = setInterval(() => {
                        setTimer(prev => prev + 1);
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [loading, isWon, isGameStarted]);

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };

            // æª¢æŸ¥æŸå€‹ä½ç½®çš„æ•¸å­—æ˜¯å¦èˆ‡ç•¶å‰ç›¤é¢è¡çª (Row, Col, Box)
            const checkConflict = (board, r, c, val) => {
                if (val === 0) return false;
                
                // æª¢æŸ¥ Row, Col (æ’é™¤è‡ªå·±)
                for (let i = 0; i < gridSize; i++) {
                    if (i !== c && board[r][i] === val) return true;
                    if (i !== r && board[i][c] === val) return true;
                }

                // æª¢æŸ¥ Box
                const { boxRows, boxCols } = getBoxInfo(gridSize);
                const startRow = Math.floor(r / boxRows) * boxRows;
                const startCol = Math.floor(c / boxCols) * boxCols;
                for (let i = 0; i < boxRows; i++) {
                    for (let j = 0; j < boxCols; j++) {
                        const rr = startRow + i;
                        const cc = startCol + j;
                        if ((rr !== r || cc !== c) && board[rr][cc] === val) return true;
                    }
                }
                return false;
            };

            // å„²å­˜ç›®å‰ç‹€æ…‹åˆ° History
            const pushHistory = () => {
                setHistory(prev => [
                    ...prev, 
                    { 
                        gameBoard: gameBoard.map(r => [...r]), 
                        notesBoard: notesBoard.map(r => [...r]) 
                    }
                ]);
            };

            const handleUndo = () => {
                if (history.length === 0 || !isGameStarted || isWon) return;
                
                const previousState = history[history.length - 1];
                setGameBoard(previousState.gameBoard);
                setNotesBoard(previousState.notesBoard);
                
                setHistory(prev => prev.slice(0, prev.length - 1));
                setHintMessage(null); // æ¸…é™¤æç¤º
            };

            const handleAIHint = () => {
                if (!isGameStarted || isWon) return;

                // 1. æª¢æŸ¥æ˜¯å¦æœ‰å·²å¡«å…¥çš„éŒ¯èª¤
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (gameBoard[r][c] !== 0 && gameBoard[r][c] !== solvedBoard[r][c]) {
                            setHintMessage(`AI åˆ†æï¼šåµæ¸¬åˆ°ç•°å¸¸ï¼ç¬¬ ${r+1} åˆ—ï¼Œç¬¬ ${c+1} è¡Œçš„æ•¸å­—å¯èƒ½æœ‰èª¤ã€‚`);
                            // è‡ªå‹•é¸å–éŒ¯èª¤æ ¼
                            setSelectedCell([r, c]);
                            setTimeout(() => setHintMessage(null), 5000);
                            return;
                        }
                    }
                }

                // 2. å¦‚æœæ²’æœ‰éŒ¯èª¤ï¼Œæç¤ºä¸€å€‹ç©ºæ ¼çš„ç­”æ¡ˆ
                // ç°¡å–®èµ·è¦‹ï¼Œéš¨æ©Ÿæ‰¾ä¸€å€‹ç©ºæ ¼
                const emptyCells = [];
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (gameBoard[r][c] === 0) {
                            emptyCells.push([r, c]);
                        }
                    }
                }

                if (emptyCells.length > 0) {
                    const [r, c] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const answer = solvedBoard[r][c];
                    setHintMessage(`AI å»ºè­°ï¼šè©¦è©¦çœ‹åœ¨ç¬¬ ${r+1} åˆ—ï¼Œç¬¬ ${c+1} è¡Œå¡«å…¥æ•¸å­— ${answer}ã€‚`);
                    setSelectedCell([r, c]);
                    setTimeout(() => setHintMessage(null), 5000);
                } else {
                    setHintMessage("AI åˆ†æï¼šç›¤é¢ä¼¼ä¹å·²ç¶“å¡«æ»¿äº†ï¼Ÿ");
                    setTimeout(() => setHintMessage(null), 3000);
                }
            };

            const handleNumberInput = (num) => {
                if (isWon || !selectedCell || !isGameStarted) return;
                if (num > gridSize) return;

                const [r, c] = selectedCell;
                if (initialBoard[r][c] !== 0) return;

                // å‹•ä½œå‰å„²å­˜æ­·å²
                pushHistory();

                if (isNoteMode) {
                    if (gameBoard[r][c] !== 0) return;
                    const newNotes = [...notesBoard];
                    newNotes[r] = [...newNotes[r]];
                    const currentNotes = new Set(newNotes[r][c]);
                    if (currentNotes.has(num)) currentNotes.delete(num);
                    else currentNotes.add(num);
                    newNotes[r][c] = Array.from(currentNotes).sort((a,b)=>a-b);
                    setNotesBoard(newNotes);
                } else {
                    const newBoard = [...gameBoard];
                    if (newBoard[r][c] === num) newBoard[r][c] = 0;
                    else {
                        newBoard[r][c] = num;
                        const newNotes = [...notesBoard];
                        newNotes[r] = [...newNotes[r]];
                        newNotes[r][c] = [];
                        setNotesBoard(newNotes);
                    }
                    setGameBoard(newBoard);
                    
                    // Check Win
                    let isFull = true;
                    let isCorrect = true;
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            if (newBoard[i][j] === 0) isFull = false;
                            if (newBoard[i][j] !== solvedBoard[i][j]) isCorrect = false;
                        }
                    }
                    if (isFull && isCorrect) setIsWon(true);
                }
            };

            const handleErase = () => {
                if (isWon || !selectedCell || !isGameStarted) return;
                const [r, c] = selectedCell;
                if (initialBoard[r][c] !== 0) return;
                
                pushHistory();

                const newBoard = [...gameBoard];
                newBoard[r][c] = 0;
                setGameBoard(newBoard);
                const newNotes = [...notesBoard];
                newNotes[r][c] = [];
                setNotesBoard(newNotes);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (isWon || !isGameStarted) return;
                    if (e.key >= '1' && e.key <= gridSize.toString()) {
                        handleNumberInput(parseInt(e.key));
                    }
                    if (e.key === 'Backspace' || e.key === 'Delete') handleErase();
                    if (e.key === 'n' || e.key === 'N') setIsNoteMode(prev => !prev);
                    // Undo shortcut
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        e.preventDefault();
                        handleUndo();
                    }
                    
                    if (selectedCell) {
                        const [r, c] = selectedCell;
                        if (e.key === 'ArrowUp') setSelectedCell([Math.max(0, r - 1), c]);
                        if (e.key === 'ArrowDown') setSelectedCell([Math.min(gridSize - 1, r + 1), c]);
                        if (e.key === 'ArrowLeft') setSelectedCell([r, Math.max(0, c - 1)]);
                        if (e.key === 'ArrowRight') setSelectedCell([r, Math.min(gridSize - 1, c + 1)]);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedCell, gameBoard, notesBoard, isWon, isNoteMode, isGameStarted, gridSize, history]);

            const getCellClass = (r, c) => {
                const val = gameBoard[r][c];
                const isInitial = initialBoard[r][c] !== 0;
                const isSelected = selectedCell && selectedCell[0] === r && selectedCell[1] === c;
                
                let isRelated = false;
                let isSameNumber = false;
                
                // æª¢æŸ¥è¡çª
                const isConflict = !isInitial && checkConflict(gameBoard, r, c, val);

                const { boxRows, boxCols } = getBoxInfo(gridSize);

                if (selectedCell) {
                    const [sr, sc] = selectedCell;
                    const sVal = gameBoard[sr][sc];
                    
                    let inBox = false;
                    const rStart = Math.floor(r/boxRows) * boxRows;
                    const cStart = Math.floor(c/boxCols) * boxCols;
                    const srStart = Math.floor(sr/boxRows) * boxRows;
                    const scStart = Math.floor(sc/boxCols) * boxCols;
                    if (rStart === srStart && cStart === scStart) inBox = true;

                    if (r === sr || c === sc || inBox) {
                        isRelated = true;
                    }
                    if (sVal !== 0 && val === sVal) {
                        isSameNumber = true;
                    }
                }

                let baseClass = "w-full h-full relative flex items-center justify-center cursor-pointer transition-colors duration-200 select-none cell-border border-[0.5px] ";
                
                if ((c + 1) % boxCols === 0 && c !== gridSize - 1) baseClass += "cell-border-bold-r ";
                if ((r + 1) % boxRows === 0 && r !== gridSize - 1) baseClass += "cell-border-bold-b ";

                if (isSelected) {
                    baseClass += "bg-cyan-500/80 text-white shadow-[0_0_15px_rgba(6,182,212,0.6)] z-10 ";
                } else if (isConflict) {
                    // è¡çªæ¨£å¼ï¼šç´…è‰²èƒŒæ™¯
                    baseClass += "bg-red-500/40 text-red-200 shadow-[inset_0_0_10px_rgba(239,68,68,0.5)] ";
                } else if (isSameNumber) {
                    baseClass += "bg-cyan-900/40 "; 
                } else if (isRelated) {
                    baseClass += "bg-slate-700/30 "; 
                } else {
                    baseClass += "hover:bg-white/5 ";
                }

                return baseClass;
            };

            const renderCellContent = (r, c) => {
                const val = gameBoard[r][c];
                const isInitial = initialBoard[r][c] !== 0;
                const isSelected = selectedCell && selectedCell[0] === r && selectedCell[1] === c;
                const isConflict = !isInitial && checkConflict(gameBoard, r, c, val);

                if (val !== 0) {
                    return (
                        <span className={`font-medium drop-shadow-md ${
                            gridSize === 9 ? 'text-lg sm:text-2xl' : 'text-xl sm:text-3xl'
                        } ${
                            // å¦‚æœè¡çªï¼Œé¡¯ç¤ºç´…è‰²æ–‡å­—ï¼›å¦å‰‡å¦‚æœæ˜¯ç©å®¶å¡«çš„ï¼Œé¡¯ç¤ºé’è‰²ï¼›å¦‚æœæ˜¯é¡Œç›®ï¼Œé¡¯ç¤ºç™½è‰²
                            isConflict ? 'text-red-300 font-bold' : (!isSelected && !isInitial ? 'text-cyan-400' : '')
                        } ${isInitial ? 'font-bold text-white' : ''} ${
                            isSelected ? 'text-white' : ''
                        }`}>
                            {val}
                        </span>
                    );
                }

                const notes = notesBoard[r] && notesBoard[r][c];
                if (notes && notes.length > 0) {
                    const gridCols = gridSize === 6 ? 'grid-cols-3' : 'grid-cols-3';
                    return (
                        <div className={`grid ${gridCols} gap-0 w-full h-full p-[2px]`}>
                            {Array.from({length: gridSize}, (_, i) => i+1).map(n => (
                                <div key={n} className="flex items-center justify-center text-[8px] sm:text-[10px] leading-none text-pink-300/80 font-medium">
                                    {notes.includes(n) ? n : ''}
                                </div>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            return (
                <div className="relative min-h-screen flex flex-col items-center py-8 font-sans text-slate-200">
                    <GenerativeBackground onColorChange={setPanelBg} />
                    
                    <div className="mb-4 flex flex-col items-center w-full max-w-[450px] px-4 z-10">
                        {/* æ¨™é¡Œèˆ‡è¨ˆæ™‚å€ */}
                        <div className="flex justify-between items-center w-full mb-4">
                            <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 drop-shadow-sm">
                                æ•¸ç¨ Sudoku
                            </h1>
                            <div className="flex items-center gap-3">
                                <div className="flex items-center text-cyan-100 px-3 py-1.5 rounded-lg border border-slate-700 shadow-sm" style={{background: panelBg}}>
                                    <Clock className="w-4 h-4 mr-2 text-cyan-400" />
                                    <span className="font-mono font-medium">{formatTime(timer)}</span>
                                </div>
                                <button 
                                    onClick={() => {
                                        if(confirm('ç¢ºå®šè¦æ”¾æ£„ç•¶å‰é€²åº¦ä¸¦é–‹å§‹æ–°éŠæˆ²å—ï¼Ÿ')) {
                                            startNewGame(difficulty, gridSize);
                                        }
                                    }}
                                    className="p-2 rounded-full transition text-cyan-100 border border-slate-700 hover:bg-white/10"
                                    style={{background: panelBg}}
                                    title="æ–°éŠæˆ²"
                                >
                                    <RefreshCw className="w-5 h-5" />
                                </button>
                            </div>
                        </div>
                        
                        {/* è¨­å®šå€ */}
                        <div className="flex flex-col w-full gap-2 p-3 rounded-lg shadow-lg glass-panel" style={{background: panelBg}}>
                            <div className="flex justify-between items-center">
                                <div className="flex items-center gap-3">
                                     <select 
                                        value={gridSize} 
                                        onChange={(e) => {
                                            const newSize = parseInt(e.target.value);
                                            if(confirm(`åˆ‡æ›ç‚º ${newSize}x${newSize} å°‡é–‹å§‹æ–°éŠæˆ²ï¼Œç¢ºå®šå—ï¼Ÿ`)) {
                                                setGridSize(newSize);
                                                startNewGame(difficulty, newSize);
                                            }
                                        }}
                                        className="bg-slate-900/50 border border-slate-600 rounded px-2 py-1 text-sm outline-none focus:border-cyan-500 text-slate-200"
                                    >
                                        <option value="9">9 x 9</option>
                                        <option value="6">6 x 6</option>
                                    </select>
                                    <select 
                                        value={difficulty} 
                                        onChange={(e) => {
                                            if(confirm('è®Šæ›´é›£åº¦å°‡é–‹å§‹æ–°éŠæˆ²ï¼Œç¢ºå®šå—ï¼Ÿ')) {
                                                setDifficulty(e.target.value);
                                                startNewGame(e.target.value, gridSize);
                                            }
                                        }}
                                        className="bg-slate-900/50 border border-slate-600 rounded px-2 py-1 text-sm outline-none focus:border-cyan-500 text-slate-200"
                                    >
                                        <option value="Easy">ç°¡å–®</option>
                                        <option value="Medium">ä¸­ç­‰</option>
                                        <option value="Hard">å›°é›£</option>
                                    </select>
                                </div>
                                <div className="text-sm text-cyan-300 font-medium">
                                    {isNoteMode ? 'âœï¸ è‰ç¨¿æ¨¡å¼' : 'âœï¸ ç­”é¡Œæ¨¡å¼'}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* AI æç¤ºè¨Šæ¯æ¡† (Toast) */}
                    {hintMessage && (
                        <div className="fixed top-20 z-50 px-6 py-3 rounded-full bg-cyan-600/90 text-white shadow-lg backdrop-blur-md animate-bounce-short border border-cyan-400">
                            <span className="flex items-center">
                                <Bot className="w-5 h-5 mr-2" />
                                {hintMessage}
                            </span>
                        </div>
                    )}

                    {isWon && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md">
                            <div className="p-8 rounded-2xl shadow-2xl flex flex-col items-center animate-bounce-short border border-cyan-500/30 glass-panel" style={{background: panelBg}}>
                                <Trophy className="w-16 h-16 text-yellow-400 mb-4 drop-shadow-[0_0_10px_rgba(250,204,21,0.5)]" />
                                <h2 className="text-3xl font-bold text-white mb-2">æ­å–œç²å‹ï¼</h2>
                                <p className="text-slate-300 mb-2">{gridSize}x{gridSize} - {difficulty}</p>
                                <p className="text-cyan-300 mb-6 font-mono text-lg">è€—æ™‚: {formatTime(timer)}</p>
                                <button 
                                    onClick={() => startNewGame(difficulty, gridSize)}
                                    className="px-6 py-2 bg-gradient-to-r from-cyan-600 to-blue-600 text-white rounded-full hover:from-cyan-500 hover:to-blue-500 transition shadow-lg flex items-center"
                                >
                                    <RefreshCw className="w-4 h-4 mr-2" />
                                    å†ä¾†ä¸€å±€
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="relative p-1 rounded-lg shadow-2xl select-none z-10 overflow-hidden glass-panel" style={{background: panelBg}}>
                        
                        {!isGameStarted && !loading && !isWon && (
                            <div className="absolute inset-0 z-40 flex flex-col items-center justify-center bg-slate-900/80 backdrop-blur-sm">
                                <div className="text-center">
                                    <div className="text-6xl mb-6">ğŸ§©</div>
                                    <button 
                                        onClick={() => setIsGameStarted(true)}
                                        className="group relative px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-full font-bold text-xl shadow-[0_0_20px_rgba(8,145,178,0.5)] transition-all hover:scale-105 active:scale-95 overflow-hidden"
                                    >
                                        <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div>
                                        <span className="relative flex items-center">
                                            <Play className="w-6 h-6 mr-2 fill-current" />
                                            {timer > 0 ? 'ç¹¼çºŒéŠæˆ²' : 'é–‹å§‹éŠæˆ²'}
                                        </span>
                                    </button>
                                </div>
                            </div>
                        )}

                        {loading ? (
                            <div className="w-[300px] h-[300px] sm:w-[450px] sm:h-[450px] flex items-center justify-center text-cyan-400">
                                ç”Ÿæˆé¡Œç›®ä¸­...
                            </div>
                        ) : (
                            <div 
                                className={`grid w-[300px] h-[300px] sm:w-[450px] sm:h-[450px] sudoku-grid border-2 transition-all duration-500 ${!isGameStarted ? 'blur-sm opacity-50' : ''} ${gridSize === 9 ? 'grid-cols-9' : 'grid-cols-6'}`}
                                style={{ touchAction: 'manipulation' }}
                            >
                                {gameBoard.map((row, r) => (
                                    row.map((num, c) => (
                                        <div
                                            key={`${r}-${c}`}
                                            onClick={() => setSelectedCell([r, c])}
                                            className={getCellClass(r, c)}
                                        >
                                            {renderCellContent(r, c)}
                                        </div>
                                    ))
                                ))}
                            </div>
                        )}
                    </div>

                    <div className="mt-4 w-full max-w-[450px] px-4 z-10">
                        
                        {/* ç¬¬ä¸€æ’æŒ‰éˆ•ï¼šç­”é¡Œã€è‰ç¨¿ã€æ¸…é™¤ */}
                        <div className="flex justify-between gap-2 mb-2">
                            <button 
                                onClick={() => setIsNoteMode(false)}
                                disabled={!isGameStarted}
                                className={`flex-1 py-3 rounded-lg flex items-center justify-center font-medium transition-all ${
                                    !isNoteMode 
                                    ? 'bg-cyan-600 text-white shadow-[0_0_10px_rgba(8,145,178,0.4)]' 
                                    : 'glass-panel text-slate-300 hover:bg-white/5'
                                } ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <span className="mr-2 text-lg">âœï¸</span> ç­”é¡Œ
                            </button>
                            <button 
                                onClick={() => setIsNoteMode(true)}
                                disabled={!isGameStarted}
                                className={`flex-1 py-3 rounded-lg flex items-center justify-center font-medium transition-all ${
                                    isNoteMode 
                                    ? 'bg-pink-600 text-white shadow-[0_0_10px_rgba(219,39,119,0.4)]' 
                                    : 'glass-panel text-slate-300 hover:bg-white/5'
                                } ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <Pencil className="w-5 h-5 mr-2" /> è‰ç¨¿
                            </button>
                            <button 
                                onClick={handleErase}
                                disabled={!isGameStarted}
                                className={`w-16 rounded-lg flex items-center justify-center glass-panel text-slate-300 hover:bg-white/10 transition-colors ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                                title="æ¸…é™¤æ ¼å­"
                                style={{background: panelBg}}
                            >
                                <Eraser className="w-6 h-6" />
                            </button>
                        </div>

                        {/* ç¬¬äºŒæ’æŒ‰éˆ•ï¼šè¿”å›ä¸Šä¸€æ­¥ã€AI æç¤º */}
                        <div className="flex justify-between gap-2 mb-4">
                            <button 
                                onClick={handleUndo}
                                disabled={!isGameStarted || history.length === 0}
                                className={`flex-1 py-2 rounded-lg flex items-center justify-center font-medium transition-all glass-panel hover:bg-white/10 ${(!isGameStarted || history.length === 0) ? 'opacity-50 cursor-not-allowed' : 'text-slate-200'}`}
                                style={{background: panelBg}}
                            >
                                <Undo className="w-5 h-5 mr-2" /> è¿”å›ä¸Šä¸€æ­¥
                            </button>
                            <button 
                                onClick={handleAIHint}
                                disabled={!isGameStarted}
                                className={`flex-1 py-2 rounded-lg flex items-center justify-center font-medium transition-all bg-indigo-600 hover:bg-indigo-500 text-white shadow-[0_0_10px_rgba(99,102,241,0.4)] ${!isGameStarted ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <Bot className="w-5 h-5 mr-2" /> AI æç¤º
                            </button>
                        </div>

                        {/* æ•¸å­—éµç›¤ */}
                        <div className={`grid gap-1 sm:gap-2 ${gridSize === 9 ? 'grid-cols-9' : 'grid-cols-6'}`}>
                            {Array.from({length: gridSize}, (_, i) => i+1).map(num => (
                                <button
                                    key={num}
                                    onClick={() => handleNumberInput(num)}
                                    disabled={!isGameStarted}
                                    className={`aspect-square flex items-center justify-center rounded shadow text-xl sm:text-2xl font-bold transition border border-white/10 ${
                                        isGameStarted 
                                        ? 'text-cyan-400 hover:bg-cyan-500/20 hover:text-cyan-200 active:bg-cyan-500/40' 
                                        : 'text-slate-600 cursor-not-allowed'
                                    }`}
                                    style={{background: panelBg}}
                                >
                                    {num}
                                </button>
                            ))}
                        </div>
                        
                        <div className="mt-4 text-center text-slate-500 text-xs">
                            éµç›¤æ·å¾‘: æ•¸å­—éµè¼¸å…¥ â€¢ æ–¹å‘éµç§»å‹• â€¢ Backspace æ¸…é™¤ â€¢ N åˆ‡æ›æ¨¡å¼ â€¢ Ctrl+Z å¾©åŸ
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
